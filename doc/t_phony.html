<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
  <head>
    <title>Phony targets</title>
  </head>

  <body>
    <h1>Phony targets</h1>

    <p>Often it is convenient to put commands into the makefile that
      don't actually build a file, but are somehow logically associated
      with the build process.  For example, a very common procedure in
      makefiles is something like this:</p>

<pre>
prefix=/usr/local

install: our_program
	install -m 0755 our_program $(prefix)/bin
	install -m 0644 *.png $(prefix)/share/our_program/icons

.PHONY: install
</pre>

    <p>When someone types <code>makepp&nbsp;install</code>, then
    <i>makepp</i> first builds <code>our_program</code>, then runs the
    commands associated with the install target.  The
    <code>install</code> command simply copies its arguments to the
    specified directory, setting the modes.  So it copies
    <code>our_program</code> into <code>/usr/local/bin</code>, and some
    associated data files into
    <code>/usr/local/share/our_program/icons</code>.  But this doesn't
    create a file called <code>install</code> in the current
    directory.</p>

    <p>The <code>install</code> target here is called a <i>phony
    target</i> because <i>makepp</i> treats it as if it were a real
    file, but it is not actually a file, it's just a device for forcing
    <i>makepp</i> to build its dependencies and then run some
    commands.</p>

    <p>That's what the line</p>
<pre>
.PHONY: install
</pre>

    <p>is for.  It tells <i>makepp</i> that it really shouldn't expect
    the file <code>./install</code> to exist after the commands have
    executed.  If you forget the phony declaration, then <i>makepp</i>
    will expect the file <code>install</code> to exist after executing
    the commands, and it will complain loudly if it does not.</p>

    <p>You can also write the phony declaration like this:</p>
<pre>
$(phony install): our_program
	...
</pre>
    <p>and then omit the <code>.PHONY:&nbsp;install</code> line.  This
    means that you can declare the target as phony on the same line as
    you define it, which may make your makefiles more readable.</p>

    <p>Phony targets are extremely common in makefiles.  In almost all
    makefiles, the first target is the phony target <code>all</code>,
    like this:</p>

<pre>
$(phony all): program1 program2 program3
</pre>

    <p>If no target is specified on the command line, <i>makepp</i>
    attempts to build the first target in the file.  If your makefile
    makes more than just one program, you most likely want to build all
    of the programs by default.  In this example, if the programmer just
    types <code>makepp</code> without any arguments, <i>makepp</i>
    attempts to build <code>all</code>, which forces it to build all
    three programs from this directory.</p>

    <p>Here is a sample makefile fragment that illustrates some commonly
    used phony targets:</p>

<pre>
PROGRAMS	:= combobulator discombobulator

$(phony all): $(PROGRAMS)	# All is the first target, so it's the default.

combobulator: $(COMBOBULATOR_OBJS)
	$(CXX) $(inputs) -o $(output)

discombobulator: $(DISCOMBOBULATOR_OBJS)
	$(CXX) $(inputs) -o $(output)

#
# This target makes sure everything is compiled, and then puts the
# programs into a place where everyone can access them.  We make the
# directories if they don't exist yet.
#
prefix	:= /usr/local

$(phony install): all
	test -d $(prefix) || mkdir $(prefix)
	test -d $(prefix)/bin || mkdir $(prefix)/bin
	for prog in $(PROGRAMS); do \
	  install -m 0755 $$prog $(prefix)/bin; \
	done
	test -d $(prefix)/share || mkdir $(prefix)/share
	test -d $(prefix)/share/combobulate || mkdir -p $(prefix)/share/combobulate
	for icon in *.xbm; do \
	  install -m 0644 $$icon $(prefix)/share/combobulate; \
	done
# Note the use of the double dollar sign to pass a single dollar sign to
# the shell.  Note also the backslashes at the end of a line to indicate
# that a shell cmomand continues to the next line.

#
# This target gets rid of all the junk that gets built during compiles.
# (Note that this could be done more thoroughly with the
# <a href="syntax_makefile.html#function_only_targets"><code>only-targets</code></a> function.)
#
$(phony clean):
	rm -f $(PROGRAMS) *.o

#
# This target makes a source distribution for shipping out to someone.
#
VERSION := 3.14

$(phony distribution):
	rm -rf combobulate-$(VERSION)	# Get rid of previous junk, if any.
	mkdir combobulate-$(VERSION)
	cp *.c *.h Makefile README INSTALL combobulate-$(VERSION)
	tar cf - combobulate-$(VERSION) | gzip -9c > combobulate-$(VERSION).tar.gz
	rm -rf combobulate-$(VERSION)

#
# This target runs regression tests to make sure the program(s) are
# doing what they are supposed to do.
#
$(phony test): $(PROGRAMS)
	noecho for testfile in *.test; do \
	   ./combobulate $$testfile | ./discombobulate - > junk_output; \
	  if cmp -s junk_output $$testfile; then \
	    echo passed $$testfile; \
	  else \
	    echo failed $$testfile; \
	  fi; \
	done
#
# If "noecho" is the first word of the action, the action itself is not
# printed before it is executed.  In this case, printing the action
# would merely clutter up the screen so it is very common to suppress
# printing for such long commands.
#
</pre>

    <hr>
    <a href="t_index.html">Tutorial index</a>
    |
    <a href="t_dirs.html">Next (multiple directories)</a>
    |
    <a href="t_pattern.html">Previous (pattern rules)</a>
    <br>
<!-- Created: Fri Aug 25 21:43:59 PDT 2000 -->
<!-- hhmts start -->
Last modified: Fri Oct 13 21:54:13 PDT 2000
<!-- hhmts end -->
  </body>
</html>

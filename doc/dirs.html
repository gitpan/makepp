<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
  <head>
    <title>Builds involving multiple directories</title>
  </head>

  <body>
    <h1>Builds involving multiple directories</h1>

    <p>One of the main motivations for writing <i>makepp</i> was to
      make it easy to do reliable builds involving multiple makefiles
      scattered across several directories.  <i>Makepp</i> avoids the
      <a href="#recursive_make">problems associated with recursive
	makes</a> and is much easier to use.  It also continues to
      support the old kludgy way of invoking make recursively, though
      this is deprecated.</p>

    <p>For a discussion of why recursive invocations of make are not
      encouraged, see the section on <a
	href="legacy_makefiles.html#recursive_make">recursive make in
	legacy makefiles</a>.</p>

    <p><i>Makepp</i>'s solution is to load all makefiles into the same
      make process.  This way, cross-makefile dependencies can be
      accurately expressed.  Each makefile needs simply to refer to the
      files it needs, and if these files are built by other makefiles,
      <i>makepp</i> figures that out automatically.  It mixes rules from
      different makefiles, first executing a rule from one makefile
      and then a rule from a different makefile, as necessary.</p>

    <p>The separate makefiles do not interfere with each other (unless
      they contain conflicting rules for building the same file) because
      <i>makepp</i> keeps all variables local to each makefile.  It also
      tags each rule with the directory its makefile was found in, and
      automatically cd's to that directory before executing the
      rule.</p>

    <p>Each makefile can be written entirely independently of the
    others.  No makefile needs to know anything about the other
    makefiles (unless it explicitly has to load them; see below).  In
    general (unless you use the <code>-f</code> option to specify the
    location of the makefile), the makefile may assume that all shell
    commands are executed with the default directory as the directory
    that contains the makefile; it does not have to know where the top
    level makefile for the build is.  In fact, makefiles which were not
    originally designed to work together will usually work together
    seamlessly.</p>

    <p>The only restriction that this architecture places on makefiles
    is that there can be only one makefile per directory.  <i>Makepp</i>
    will give an error message if you try to load two makefiles for the
    same directory.  This is for technical internal reasons (the phony
    targets would get confused).</p>

    <p>How does <i>makepp</i> figure out which makefiles are needed?
    There are two ways (besides explicit invocation of recursive make,
    which is discouraged): it can guess where the makefiles are, or you
    can tell it explicitly.</p>

    <h2>Implicit makefile loading</h2>

    <p>The simplest way of building a system that spans multiple
      directories is to allow <i>makepp</i> to figure out automatically
      which makefiles need to be loaded.  If <i>makepp</i> needs to use
      a file, and there is currently no build command known for the
      file, <i>makepp</i> first looks in the directory that contains or
      will contain that file to see if there is a makefile there.  It
      first looks for <code>Makeppfile</code>, then
      <code>makefile</code>, then <code>Makefile</code>.  If one of
      these files is found, it is loaded into <i>makepp</i>, and any
      build instructions that it contains are now available.</p>

    <p><i>Makepp</i> does not attempt to load makefiles from directories
    which are not writable.  This is because it couldn't build files in
    such directories anyway, and it assumes that they won't change since
    the user running <i>makepp</i> can't write to them.</p>

    <p>Since most existing makefiles are designed to produce output
    files in the same directory as the makefile, this rule usually finds
    the relevant build instructions.</p>

    <p>Implicit makefile loading can make builds that span even many
    directories quite simple.  Each directory simply needs to contain a
    makefile that builds anything which is supposed to be contained in
    that directory.  If any other makefile needs to access a file in
    that directory, it simply lists it in a dependency list;
    <i>makepp</i> then automatically figures out that it needs to read
    in another makefile.</p>

    <p>For a concrete example of this, see the <a
    href="t_dirs.html">tutorial section on working with multiple
    directories.</a></p>

    <p>Implicit loading will not work for you if:</p>
    <ul>
      <li>Your makefiles are located in a different directory than the
	files they produce, e.g., if you put architecture-dependent
	binaries in a separate directory.

      <li>You need to override some variables in the makefile.

      <li>Your makefile is not called <code>Makeppfile</code>,
	<code>makefile</code>, or <code>Makefile</code>.  (But why did
	you pick such a strange name for your makefile?)
    </ul>

    <p>If any of these are true, then you need to use the
      <code>load_makefile</code> statement.</p>

    <p>Sometimes implicit makefile loading loads too many makefiles.
    For example, if you have many directories which contain makefiles,
    but they just contain libraries which are never modified and never
    need to be recompiled, then there is no real reason for
    <i>makepp</i> to load the makefiles from those directories.  Either
    make the directories non-writable, or else turn off implicit
    makefile loading by adding the <a
    href="command_line.html#option_no_implicit_load"><code>-noimplicit-load</code></a>
    option to the command line.</p>

    <h2>The load_makefile statement</h2>

<pre>
load_makefile subdir1/Makefile /other/dir/Makeppfile
load_makefile VAR=value dir1 dir2
</pre>

    <p>(See the section on <a
    href="syntax_makefile.html#load_makefile_statement">makefile
    syntax</a> for the syntax.)

    <p>This causes <i>makepp</i> to load the rules in the specified
      makefile(s).  You must use this statement if:</p>
    <ul>
      <li>Implicit makefile loading is not finding all the necessary
	makefiles.
      <li>You need to override a variable in the makefile.
      <li>You need to specify the makefile's name.
      <li>You have turned off implicit makefile loading.
    </ul>

    <p>If you have implicit makefile loading turned on, and you are
    using the <code>load_makefile</code> statement because you need to
    override a variable in the other makefile, then the
    <code>load_makefile</code> statement must occur before any rules
    that depend on files that the other makefile builds.  Otherwise, the
    makefile will first be implicitly loaded, and then when you try to
    load the makefile again with a different set of variables,
    <i>makepp</i> will detect this and give you an error message.</p>

    <hr>
    <a href="index.html">Table of contents</a>
    |
    <a href="repositories.html">Next (repositories and variant builds)</a>
    |
    <a href="command_line.html">Previous (command line syntax)</a>
    <br>
<!-- Created: Sat Oct 14 21:09:39 PDT 2000 -->
<!-- hhmts start -->
Last modified: Sat Oct 14 22:37:30 PDT 2000
<!-- hhmts end -->
  </body>
</html>

<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
  <head>
    <title>Extending Makepp</title>
  </head>

  <body>
    <h1>Extending Makepp</h1>

    <p><i>Makepp</i> internally is flexible enough so that by writing a
    little bit of perl code, you can change any of the following:</p>

    <ul>
      <li>You can <a href="#new_functions">add new functions</a>.
	
      <li>You can change the way <i>makepp</i> computes and compares
      signatures.  (See the <a
      href="syntax_makefile.html#colon_signature"><code>:signature</code></a>
      modifier for rules.)

      <li>You can change the way <i>makepp</i> scans for dependencies
      such as include files.  (See the <a
      href="syntax_makefile.html#:scanner"><code>:scanner</code>
      modifier for rules, and the <a href="scanning.html">section on
      dependency scanning</a>.)

      <li>You can get <i>makepp</i> to support new kinds of objects
      other than files.  For example, it is possible to tell
      <i>makepp</i> how to handle URLs or database records as targets or
      dependencies of rules.  [This section not finished yet.]

      <li>You can change the way <i>makepp</i> executes rule actions.
      For example, you could write your own perl code to have
      <i>makepp</i> automatically distribute jobs to different machines.
      [This section not finished yet.]

    </ul>

    <hr>

    <h2>General notes on writing perl code to work with makepp</h2>

    <p>Each makefile lives in its own package.  Thus definitions in one
    makefile do not affect definitions in another makefile.  A common
    set of functions including all the standard textual manipulation
    functions is imported into the package when it is created.</p>

    <p>Makefile variables (except <a
    href="syntax_makefile.html#automatic_variables">automatic
    variables</a>, which are actually implemented as functions) are
    stored as perl scalars in that package.  Thus any perl code you
    write has access to all makefile variables, and any global variables
    you set can be accessed from the makefile.</p>


    <hr>

    <a name="new_functions"></a>
    <h2>Adding new textual functions</h2>

    <p>You can add a new function to <i>makepp</i>'s repertoire
      by simply defining a perl subroutine of the same name but with a
      prefix of <code>f_</code>.  For example:</p>

<pre>
<a href="syntax_makefile.html#sub_statement">sub</a> f_myfunc {
  my $argument = $_[0]; 	# Name the arguments.

  .. do something here

  return $return_value;
}

XYZ := $(my_func my func arguments)
</pre>

    <p>The first argument to the function is the remaining text in the
    function invocation after the function name.  You'll have to split
    it into words yourself if that's what you want.  There are other
    arguments, but I can't imagine anyone except <i>makepp</i>'s
    internal routines wanting to use them.</p>

    <p>The function should return a scalar string (not an array) which
      is then inserted into the text at that point.</p>

    <p>At present, expressions appearing in dependencies and in the rule
      actions are expanded once while expressions appearing in targets
      are expanded twice.</p>

    <p>There are essentially no limits on what the function can do; you
      can access the file, run shell commands, etc.</p>

    <hr>

    [This document is not finished yet.]

    <hr>

    <a href="index.html">Table of contents</a>
    |
    <a href="legacy_makefiles.html">Next (legacy makefiles)</a>
    |
    <a href="build_algorithm.html">Previous (build algorithm)</a>
    <br>
<!-- Created: Wed Aug  9 19:43:36 PDT 2000 -->
<!-- hhmts start -->
Last modified: Thu Aug 10 08:00:53 PDT 2000
<!-- hhmts end -->
  </body>
</html>

<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
  <head>
    <title>Signature Checking</title>
  </head>

  <body>
    <h1>Signature Checking</h1>

    <p>Each file is associated with a <i>signature</i>, which is a
    number or string that changes if the file has changed.
    <i>Makepp</i> compares signatures to see whether it needs to rebuild
    anything.  The default signature is the file's modification time.
    However, if you want you can change this to be a cryptographic
    checksum on the file's contents, or you can even define your own
    signature functions.  You can also change how <i>makepp</i> compares
    signatures.</p>

    <p>In addition to the file's signature, it is also possible to
    control how <i>makepp</i> compares these signature values.  For
    example, the <code>exact_match</code> method requires that file
    signatures be exactly the same as on the last build, wheresa the
    <code>target_newer</code> method only requires that all dependencies
    be older than the target.</p>

    <p>If <i>makepp</i> is building a file, and you don't think it
    should be, you might want to check the build log
    (<code>.makepp_log</code>).  <i>Makepp</i> writes an explanation of
    what it thought each file dependended on, and why it chose to
    rebuild.</p>

    <p>At present, there are three signature checking methods included
    in <i>makepp</i>.</p>

    <h2>exact_match</h2>

    <p>This method uses the modification dates on the file as
    signatures.  It rebuilds the targets unless all of the following
    conditions are true:</p>

    <ul>
      <li>The signature of each dependency is the same as it was on the
	last build.
      <li>The signature of each target is the same as it was on the last
	build.
      <li>The build command has changed.
      <li>The default directory for the build command has changed.
      <li>The machine architecture (or what perl thinks it is) has
	changed.
    </ul>

    <p><i>Makepp</i> stores all the signature information and the build
      command from the last build, so that it can do these comparisons.</p>

    <p>This is <i>makepp</i>'s default algorithm unless it is trying to
    rebuild a makefile.  This is a highly reliable way of ensuring
    correct builds, and is almost always what you want.  However, it
    does have a few side effects that may be surprising:</p>

    <ul>
      <li>If you've been compiling with the traditional make, and then
      switch to <i>makepp</i>, everything is recompiled the first time
	you run <i>makepp</i>.

      <li>If you damage <i>makepp</i>'s information about what happened
      on the last build (e.g., you delete the subdirectory
      <code>.makepp</code>, or don't copy it when you copy everything
      else), then a rebuild is triggered.

      <li>If you replace a file with an older version, a rebuild is
	triggered.

      <li>If you modify a file outside of the control of <i>makepp</i>
	(e.g., you run the compilation command yourself), then
	<i>makepp</i> will rebuild the file next time.

      <li>Architecture-independent files are rebuild when you switch to
	a different architecture.  This is usually not a problem,
	because they often don't take long to build.  The reason why all
	files are tagged with the architecture, instead of just binary
	files, is that often times even ASCII files are
	architecture-dependent.  For example, output from the solaris
	<code>lex</code> program won't compile on linux.
    </ul>


    <h2>target_newer</h2>

    <p>Rebuilds only if the target is newer than all of its
    dependencies.  The dependencies may change their time stamp, but as
    long as they are older than the target, the target is not rebuilt.
    The target is also not rebuilt even if the command or the
    architecture has changed.  (This is the signature method that the
    traditional make uses.)</p>
	  
    <p>This is <i>makepp</i>'s default algorithm if it is trying to
    build the makefile before reading it in.  (It loads the makefile and
    checks for a rule within the makefile to rebuild itself, and if such
    a rule is present and the makefile needs rebuilding, it is rebuild
    and then reread.)  This is because it is common to modify a makefile
    using commands that are not under the control of <i>makepp</i>,
    e.g., running a configure procedure.  Thus <i>makepp</i> doesn't
    insist that the last modification to the makefile be made by
    itself.</p>


    <a name="c_compilation_md5"></a>

    <h2>c_compilation_md5</h2>

    <p>This is the same as <code>exact_match</code>, except that
    signatures for files which look like C or C++ source files are
    computed by an MD5 checksum of the file, ignoring comments and
    whitespace.  Ordinary file times are still used for signatures for
    object files, or any files that don't have an extension typical of a
    C or C++ source file.  (A file is considered to be source code if it
    has an extension of <code>c</code>, <code>h</code>, <code>cc</code>,
    <code>hh</code>, <code>cxx</code>, <code>hxx</code>,
    <code>hpp</code>, <code>cpp</code>, <code>h++</code>,
    <code>c++</code>, <code>moc</code>, or upper case versions of
    these.)  If you use this, you can reindent your code or add or
    change comments without triggering a rebuild.</p>

    <p>This method is particularly useful for the following situations:</p>
    <ul>
      <li>You want to make changes to the comments in a commonly
      included header file, or you want to reformat or reindent part of
      it.  For one project that I worked on, we were very unwilling to
      correct inaccurate comments in a common header file, even when
      they were seriously misleading, because doing so would trigger
      several hours of rebuilds.

      <li>You like to save your files often, and your editor (unlike
	emacs) will happily write a new copy out even if nothing has
	changed.

      <li>You have C/C++ source files which are generated automatically
      by other build commands (e.g., yacc or some other preprocessor).
      For one system I work with, we have a preprocessor which (like
      yacc) produces two output files, a <code>.cxx</code> and a
      <code>.h</code> file:
<pre>
%.h %.cxx: %.qtdlg $(HLIB)/Qt/qt_dialog_generator
	$(HLIB)/Qt/qt_dialog_generator $(input)
</pre>
	<p>However, most of the time when the input file changes, the
	  resulting <code>.h</code> file contents are unchanged (except
	  for a comment about the build time written by the preprocessor),
	  although its date will change.  This could trigger unnecessary
	  rebuilds of many modules without this kind of cryptographic
	  signature checking.</p>
    </ul>


    <p>This is the default signature method for C or C++ compilation if
    you have the following line somewhere in your makefile:</p>

<pre>
<a href="#statement_include">include</a> c_compilation_md5.mk
</pre>

    <p>Without the above statement, this method is not available at all
    for build commands in that makefile.  (You must put this statement
    in each makefile that has a compilation command.)  If you want to
    use an explicit <code>:signature&nbsp;c_compilation_md5</code>
    clause, then the above statement must be before the rule containing
    the clause.</p>

    <p>This method is not included by default because (a) it's slightly
    slower than checking file times; (b) not everyone has the
    appropriate perl module (Digest::MD5) to do the signature
    calculation.</p>

    <h2>Custom methods</h2>

    <p>You can, if you want, define your own methods for calculating
    file signatures and comparing them.  You will need to write a perl
    module to do this.  Have a look at the comments in
    <code>Signature.pm</code> in the distribution, and also at the
    existing signature algorithms in <code>Signature/*.pm</code> for
    details.</p>

    <hr>
    <a href="index.html">Table of contents</a>
    |
    <a href="syntax_makefile.html">Next (makefile syntax)</a>
    |
    <a href="t_index.html">Previous (tutorial)</a>
    <br>
<!-- Created: Sat Oct 14 17:21:19 PDT 2000 -->
<!-- hhmts start -->
Last modified: Sat Oct 14 22:40:59 PDT 2000
<!-- hhmts end -->
  </body>
</html>

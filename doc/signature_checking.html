<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
  <head>
    <title>Signature Checking</title>
  </head>

  <body>
    <h1>Signature Checking</h1>

    <p>Each file is associated with a <i>signature</i>, which is a
    number or string that changes if the file has changed.
    <i>Makepp</i> compares signatures to see whether it needs to rebuild
    anything.  The default signature for files is the file's
    modification time, unless you're executing a C/C++ compilation
    command, in which case the default signature is a cryptographic
    checksum on the file's contents, ignoring comments and whitespace.
    If you want, you can switch to a different method, or you can define
    your own signature functions.</p>

    <p>In addition to the file's signature, it is also possible to
    control how <i>makepp</i> compares these signature values.  For
    example, the <code>exact_match</code> method requires that file
    signatures be exactly the same as on the last build, whereas the
    <code>target_newer</code> method only requires that all dependencies
    be older than the target.</p>

    <p>If <i>makepp</i> is building a file, and you don't think it
    should be, you might want to check the build log
    (<code>.makepp_log</code>).  <i>Makepp</i> writes an explanation of
    what it thought each file depended on, and why it chose to
    rebuild.</p>

    <p>At present, there are four signature checking methods included in
    <i>makepp</i>.  These methods may be selected on a rule-by-rule
    basis by using the <a
    href="syntax_makefile.html#colon_signature"><code>:signature</code>
    modifier</a>, or on a makefile-by-makefile basis by using the <a
    href="syntax_makefile.html#statement_signature"><code>signature</code></a>
    statement, or for all makefiles at once by using the <a
    href="command_line.html#option_signature_method"><code>-m</code> or
    <code>--signature-method</code> command line option</a>.  Usually,
    <i>makepp</i>'s default is fine.</p>

    <h2>exact_match</h2>

    <p>This method uses the modification dates on the file as
    signatures.  It rebuilds the targets unless all of the following
    conditions are true:</p>

    <ul>
      <li>The signature of each dependency is the same as it was on the
	last build.
      <li>The signature of each target is the same as it was on the last
	build.
      <li>The build command has changed.
      <li>The default directory for the build command has changed.
      <li>The machine architecture (or what perl thinks it is) has
	changed.
    </ul>

    <p><i>Makepp</i> stores all the signature information and the build
      command from the last build, so that it can do these comparisons.</p>

    <p>This is <i>makepp</i>'s default algorithm unless it is trying to
    rebuild a makefile or compile C/C++ code.  This is a highly reliable
    way of ensuring correct builds, and is almost always what you want.
    However, it does have a few side effects that may be surprising:</p>

    <ul>
      <li>If you've been compiling with the traditional make, and then
      switch to <i>makepp</i>, everything is recompiled the first time
	you run <i>makepp</i>.

      <li>If you damage <i>makepp</i>'s information about what happened
      on the last build (e.g., you delete the subdirectory
      <code>.makepp</code>, or don't copy it when you copy everything
      else), then a rebuild is triggered.

      <li>If you replace a file with an older version, a rebuild is
	triggered.

      <li>If you modify a file outside of the control of <i>makepp</i>
	(e.g., you run the compilation command yourself), then
	<i>makepp</i> will rebuild the file next time.

      <li>Architecture-independent files are rebuild when you switch to
	a different architecture.  This is usually not a problem,
	because they often don't take long to build.  The reason why all
	files are tagged with the architecture, instead of just binary
	files, is that often times even ASCII files are
	architecture-dependent.  For example, output from the solaris
	<code>lex</code> program won't compile on linux.
    </ul>


    <h2>target_newer</h2>

    <p>Rebuilds only if the target is newer than all of its
    dependencies.  The dependencies may change their time stamp, but as
    long as they are older than the target, the target is not rebuilt.
    The target is also not rebuilt even if the command or the
    architecture has changed.  (This is the signature method that the
    traditional make uses.)</p>
	  
    <p>This is <i>makepp</i>'s default algorithm if it is trying to
    build the makefile before reading it in.  (It loads the makefile and
    checks for a rule within the makefile to rebuild itself, and if such
    a rule is present and the makefile needs rebuilding, it is rebuild
    and then reread.)  This is because it is common to modify a makefile
    using commands that are not under the control of <i>makepp</i>,
    e.g., running a configure procedure.  Thus <i>makepp</i> doesn't
    insist that the last modification to the makefile be made by
    itself.</p>


    <p>Using <code>target_newer</code> compared to
    <code>exact_match</code> has the following disadvantages:</p>

    <ul>
      <li><i>makepp</i> can be confused by clock synchronization
	or by bogus dates.   For example, if a file somehow gets a date
	in the far future, anything that depends on it will always be
	rebuilt, no matter what.

      <li>Replacing a file with an older version of the same file won't
	trigger a rebuild.

      <li>Changing the build command (e.g., changing compilation
      options) won't trigger a rebuild.b

      <li>Changing the architecture (e.g., switching from linux to
      solaris) won't trigger a rebuild.
    </ul>

    <a name="md5"></a>
    <h2>md5</h2>

    <p>This is the same as <code>exact_match</code>, except that instead
    of using the file date as the signature, an MD5 checksum of the
    files contents is used.  This means that if you change the date on
    the file but don't change its contents, <i>makepp</i> won't try to
    rebuild anything that depends on it.</p>

    <p>This is particularly useful if you have some file which is often
    regenerated during the build process that other files depend on, but
    which usually doesn't change.  This will not work properly for
    libraries or other files which have compilation times contained in
    the file itself.</p>

    <p>For C/C++ source code, you should use
      <code>c_compilation_md5</code> instead.</p>

    <a name="c_compilation_md5"></a>

    <h2>c_compilation_md5</h2>

    <p>This is the same as <code>md5</code>, except that signatures for
    files which look like C or C++ source files are computed by an MD5
    checksum of the file, ignoring comments and whitespace.
    (Technically, comments are replaced by a single space, and multiple
    whitespace is collapsed to a single space, before computing the MD5
    checksum.)  Ordinary file times are still used for signatures for
    object files, and any other files that don't have an extension
    typical of a C or C++ source file.  (A file is considered to be
    source code if it has an extension of <code>c</code>,
    <code>h</code>, <code>cc</code>, <code>hh</code>, <code>cxx</code>,
    <code>hxx</code>, <code>hpp</code>, <code>cpp</code>,
    <code>h++</code>, <code>c++</code>, <code>moc</code>, or upper case
    versions of these.)  If you use this, you can reindent your code or
    add or change comments without triggering a rebuild.</p>

    <p>This method is particularly useful for the following situations:</p>
    <ul>
      <li>You want to make changes to the comments in a commonly
      included header file, or you want to reformat or reindent part of
      it.  For one project that I worked on, we were very unwilling to
      correct inaccurate comments in a common header file, even when
      they were seriously misleading, because doing so would trigger
      several hours of rebuilds.

      <li>You like to save your files often, and your editor (unlike
      emacs) will happily write a new copy out even if nothing has
      changed.

      <li>You have C/C++ source files which are generated automatically
      by other build commands (e.g., yacc or some other preprocessor).
      For one system I work with, we have a preprocessor which (like
      yacc) produces two output files, a <code>.cxx</code> and a
      <code>.h</code> file:
<pre>
%.h %.cxx: %.qtdlg $(HLIB)/Qt/qt_dialog_generator
	$(HLIB)/Qt/qt_dialog_generator $(input)
</pre>
	<p>However, most of the time when the input file changes, the
	resulting <code>.h</code> file contents are unchanged (except
	for a comment about the build time written by the preprocessor),
	although its date will change.  This could trigger unnecessary
	rebuilds of many modules without this kind of cryptographic
	signature checking.</p>
    </ul>

    <p>This is the default signature method for C or C++ compilation.
    It overrides any default specified with the <a
    href="command_line.html#option_signature_method"><code>-m</code> or
    <code>--signature-method</code> command line option</a>, but is
    overridden by any signature method specified by the <a
    href="syntax_makefile.html#statement_signature"><code>signature</code></a>
    statement or the <a
    href="syntax_makefile.html#colon_signature"><code>:signature</code>
    rule modifier</a>.  <i>Makepp</i> determines that you are doing a
    C/C++ compilation if it recognizes your command line as an
    invocation of a C/C++ compiler (see on <a
    href="scanning.html">scanning</a>).

    <h2>Custom methods</h2>

    <p>You can, if you want, define your own methods for calculating
    file signatures and comparing them.  You will need to write a perl
    module to do this.  Have a look at the comments in
    <code>Signature.pm</code> in the distribution, and also at the
    existing signature algorithms in <code>Signature/*.pm</code> for
    details.</p>

    <hr>
    <a href="index.html">Table of contents</a>
    |
    <a href="syntax_makefile.html">Next (makefile syntax)</a>
    |
    <a href="t_index.html">Previous (tutorial)</a>
    <br>
<!-- Created: Sat Oct 14 17:21:19 PDT 2000 -->
<!-- hhmts start -->
Last modified: Mon Feb 19 14:52:08 PST 2001
<!-- hhmts end -->
  </body>
</html>

<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
  <head>
    <title>Working with several directories</title>
  </head>

  <body>
    <h1>Working with several directories</h1>

    <p>If your program grows to a substantial size, or if it uses
    libraries that need to be built but should be kept separate, it is
    quite likely that you have split up your sources into several
    directories.  One of the main motivations for writing <i>makepp</i>
    was to make dealing with several directories much easier than with
    the standard make utility.  If you're familiar with the standard
    unix make, you'll notice that with <i>makepp</i>, you don't have to
    mess around with ugly complexities like recursive invocations of
    make.</p>

    <p>With <i>makepp</i>, you simply put a separate makefile in each
    directory that builds the relevant files in that directory.  When a
    makefile refers to files whose build commands are in different
    makefiles, <i>makepp</i> automatically finds the appropriate build
    rules in the other makefiles.  All actions in each makefile are
    executed with the current directory set to be the directory
    containing the makefile, so each makefile can be written
    independently of all the others.  No makefile has to know anything
    about the other makefiles; it does not even have to tell
    <i>makepp</i> to load the rules from those other makefiles.</p>

    <p>When you've written your makefiles, cd to the directory that
    contains your main program, and type <code>makepp</code> just like
    you usually would.  <i>Makepp</i> will load in the makefile from
    that directory.  It will notice that this makefile refers to files
    in other directories, and it will examine those other directories to
    see if there is a makefile in them.  In this way, all relevant
    makefiles will be loaded.</p>

    
    <p>As a simple example, suppose your top level directory contains
      the following makefile:</p>
<pre>
# Top level makefile:

CXX	:= c++
CXXFLAGS := -O2
my_program: main.o goodies/libgoodies.so
	$(CXX) $(inputs) -o $(output)

%.o: %.cxx
	$(CXX) $(CXXFLAGS) -c $(input) -o $(output)
</pre>

    <p>You would need to write a makefile in the directory
      <code>goodies</code> which builds <code>libgoodies.so</code>, like
      this:</p>

<pre>
# goodies/Makefile

CXX	:= c++
CXXFLAGS := -O2

MODULES = candy.o chips.o licorice.o cookies.o popcorn.o spinach.o

libgoodies.so: $(MODULES)
	$(CXX) -shared $(inputs) -o $(output)
			# Note that the command is written assuming that
			# the current directory is the subdirectory
			# "goodies", not the top level subdirectory.
			# Makepp cds into this directory before executing
			# any commands from this makefile.

%.o: %.cxx
	$(CXX) $(CXXFLAGS) -fpic -c $(input) -o $(output)
</pre>

    <p>And that's all you need to do.</p>

    <br>

    <p>Any variables which you specify on the command line override the
    definition of the variable in <i>all</i> makefiles.  Thus, for
    example, if you type <code>makepp&nbsp;CXXFLAGS="-g"</code>, all
    modules will be recompiled for debug because the definition of
    <code>CXXFLAGS</code> in both makefiles is overridden.</p>

    <p>The directories containing other sources need not be
    subdirectories of the top-level directory (as they are in this
    example).  They can be anywhere in the file system; <i>makepp</i>
    will automatically load a makefile from any directory that contains
    a file which is a dependency of some target it is trying to build.
    It will also load a makefile from any directory that is scanned by a
    wildcard.</p>

    <p>Automatic loading works if files built by your makefile all
    reside in the same directory as the makefile itself.  If you write
    your makefile so that its rules produce files in a different
    directory than the makefile itself, then you might have to tell
    <i>makepp</i> where to look for the makefiles, since it doesn't have
    any way of guessing.  You can do this using the <a
    href="syntax_makefile.html#load_makefile_statement"><code>load_makefile</code></a>
    statement in your makefile.  For more information about this and
    other issues related to multi-directory builds, see <a
    href="dirs.html">the section on directories in the reference
    manual</a>.</p>

    <p>One caveat: if you reference the variable <code>$(MAKE)</code> in
    your makefile, <i>makepp</i> automatically goes into backward
    compatibility mode and turns off automatic loading.</p>

    <h2>Template or boilerplate files</h2>

    <p><i>Makepp</i> has several other features which make life slightly
    easier for programmers who have to maintain a program spanning
    several directories.  In the above examples, you'll notice that the
    definitions of the variables <code>CXX</code> and
    <code>CXXFLAGS</code> have to be repeated in each makefile.  It can
    be a nuisance to reenter the same information into every makefile,
    and it could be a problem if you ever decide to change it--you may
    have to modify dozens of different makefiles.</p>

    <p>What you can do instead is to put all of the information that's
    common to each makefile into a separate file, located perhaps at the
    top of the directory tree.  Common information usually includes
    variable definitions, and sometimes also pattern rules.  (In the
    above example, however, the pattern rules are not the same in both
    makefiles.)  Let's suppose you've called this file
    <code>standard_defs.mk</code>.  Then each makefile simply needs to
    contain a statement like this:</p>

<pre>
include standard_defs.mk
</pre>

    <p>When <i>makepp</i> sees this statement, it inserts the contents
    of the file into the makefile at that point.  The
    <code>include</code> statement first looks for the file in the
    current directory, then in the parent of the current directory, and
    so on up to the top level of the file system, so you don't actually
    need to specify <code>../standard_defs.mk</code> or
    <code>../../../../standard_defs.mk</code>.</p>

    <p>So we could rewrite the above makefiles to look like this.
      <code>standard_defs.mk</code> would exist in the top level
      directory, and it might contain the following definitions:</p>

<pre>
# standard_defs.mk
CXX	:= c++
CXXFLAGS := -O2

#
# We've also included a pattern rule that might be useful in one or more
# subdirectories.  This pattern rule is for C compilation for putting
# things into a shared library (that's what the -fpic option is for).
#
%.o: %.cxx
	$(CXX) $(CXXFLAGS) -fpic -c $(input) -o $(output)
</pre>

    <p>Note that since the included file is actually inserted into each
    makefile, rules in the included file are applied with the default
    directory set to the directory containing the makefile that included
    the file, not the directory containing the include file.</p>

    <p>The top level <code>Makefile</code> might look like this:</p>

<pre>
# Top level makefile
include standard_defs.mk

my_program: main.o goodies/libgoodies.so
	$(CXX) $(inputs) -o $(output)

#
# Note that this pattern rule overrides the one found in standard_defs.mk,
# because makepp sees it later.  This pattern rule is for compilation for
# a module that doesn't belong in a shared library.
#
%.o: %.cxx
	$(CXX) $(CXXFLAGS) $(input) -o $(output)
</pre>

    <p>And the subdirectory's makefile might look like this:</p>
<pre>
# goodies/Makefile
include standard_defs.mk

MODULES = candy.o chips.o licorice.o cookies.o popcorn.o spinach.o

libgoodies.so: $(MODULES)
	$(CXX) -shared $(inputs) -o $(output)

# We don't need the pattern rule for compilation of .cxx to .o files, because
# it's contained in standard_defs.mk.
</pre>

    <h2>The -F compilation option</h2>

    <p>If you run <i>makepp</i> from within an editor such as emacs, and
    you are editing sources from several different directories, you may
    find that the default directory for <i>makepp</i> differs depending
    on which file you were most recently editing.  As a result,
    <i>makepp</i> may not load the correct makefile.</p>

    <p>What you can do to ensure that <i>makepp</i> always loads the
      correct makefile(s), no matter what directory happens to be your
      current directory, is to use the <a href="command_line.html#option_F"><code>-F</code></a> command line
      option, like this:</p>

<pre>
makepp -F ~/src/my_program
</pre>

    <p><i>Makepp</i> will first cd to the directory
    <code>~/src/my_program</code> before it attempts to load a
    makefile.</p>

    <hr>
    <a href="t_index.html">Tutorial index</a>
    |
    <a href="t_wildcards.html">Next (wildcards)</a>
    |
    <a href="t_phony.html">Previous (phony targets)</a>
    <br>
<!-- Created: Wed Aug 23 23:00:24 PDT 2000 -->
<!-- hhmts start -->
Last modified: Mon Feb 19 15:51:33 PST 2001
<!-- hhmts end -->
  </body>
</html>

<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
  <head>
    <title>Unix Compilation Commands</title>
  </head>

  <body>
    <h1>Unix Compilation Commands</h1>

    <p>Feel free to <a href="t_simplest.html">skip this page</a> if you
    feel you have a good grasp on what the compilation commands do.</p>

    <p>I find that distressingly few people seem to be taught in their
    programming classes is how to go about compiling programs once
    they've written them.  Novices rely either on a single memorized
    command, or else on the builtin rules in make.  I have been
    surprised by extremely computer literate people who learned to
    compile with optimization because they simply never were told how
    important it is.  Rudimentary knowledge of how compilation commands
    work may make your programs run twice as fast or more, so it's worth
    at least five minutes.  This page describes just about everything
    you'll need to know to compile C or C++ programs on just about any
    variant of unix.</p>

    <p>The examples will be mostly for C, since C++ compilation is
    identical except that the name of the compiler is different.
    Suppose you're compiling source code in a file called
    <code>xyz.c</code> and you want to build a program called
    <code>xyz</code>.  What must happen?</p>

    <p>You may know that you can build your program in one step, using a
      command like this:</p>
<pre>
cc -g xyz.c -o xyz
</pre>

    <p>This will work, but it conceals a two-step process that you must
    understand if you are writing makefiles.  (Actually, there are more
    than two steps, but you only have to understand two of them.)  For a
    program of more than one module, the two steps are usually
    explicitly separated.</p>

    <h2>Compilation</h2>

    <p>The first step is the translation of your C or C++ source code
    into a binary file called an object file.  Object files usually have
    an extension of <code>.o</code>. (For some more recent projects,
    <code>.lo</code> is also used for a slightly different kind of
    object file.)</p>

    <p>The command to produce an object file on unix looks something
      like this:</p>

<pre>
cc -g -c xyz.c -o xyz.o
</pre>

    <p><code>cc</code> is the C compiler.  Sometimes alternate C
    compilers are used; a very common one is called <code>gcc</code>.  A
    common C++ compiler is the GNU compiler, usually called
    <code>g++</code>.  Virtually all C and C++ compilers on unix have
    the same syntax for the rest of the command (at least for basic
    operations), so the only difference would be the first word.</p>

    <p>We'll explain what the <code>-g</code> option does later.</p>

    <p>The <code>-c</code> option tells the C compiler to produce a
    <code>.o</code> file as output.  (If you don't specify
    <code>-c</code>, then it performs the second compilation step
    automatically.)</p>

    <p>The <code>-o&nbsp;xyz.o</code> option tells the compiler what the
      name of the object file is.  You can omit this, as long as the
      name of the object file is the same as the name of the source file
      except for the <code>.o</code> extension.</p>

    <p>For the most part, the order of the options and the file names
    does not matter.  One important exception is that the output file
    must immediately follow <code>-o</code>.</p>

    <h2>Linking</h2>


    <p>The second step of building a program is called <i>linking</i>.
    An object file cannot be run directly; it's an intermediate form
    that must be <i>linked</i> to other components in order to produce a
    program.  Other components might include:
    <ul>
      <li>Libraries.  A <i>library</i>, roughly speaking, is a
      collection of object modules that are included as necessary.  For
      example, if your program calls the <code>printf</code> function,
      then the definition of the <code>printf</code> function must be
      included from the system C library.  Some libraries are
      automatically linked into your program (e.g., the one containing
      <code>printf</code>) so you never need to worry about them.</p>

      <li>Object files derived from other source files in your program.
      If you write your program so that it actually has several source
      files, normally you would compile each source file to a separate
      object file and then link them all together.
    </ul>

    <p>The <i>linker</i> is the program responsible for taking a
      collection of object files and libraries and linking them together
      to produce an executable file.  The executable file is the program
      you actually run.</p>

    <p>The command to link the program looks something like this:</p>
<pre>
cc -g xyz.o -o xyz
</pre>

    <p>It may seem odd, but we usually run the same program
    (<code>cc</code>) to perform the linking.  What happens under the
    surface is that the <code>cc</code> program immediately passes off
    control to a different program (the linker, sometimes called the
    loader, or <code>ld</code>) after addding a number of complex pieces
    of information to the command line.  For example, <code>cc</code>
    tells <code>ld</code> where the system library is that includes the
    definition of functions like <code>printf</code>.  Until you start
    writing shared libraries, you usually do not need to deal directly
    with <code>ld</code>.</p>

    <p>If you do not specify <code>-o&nbsp;xyz</code>, then the output
    file will be called <code>a.out</code>, which seems to me to be a
    completely useless and confusing convention.  So always specify
    <code>-o</code> on the linking step.</p>

    <p>If your program has more than one object file, you should specify
    all the object files on the link command.</p>

    <h2>Why you need to separate the steps</h2>

    <p>Why not just use the simple, one-step command, like this:</p>

<pre>
cc -g xyz.c -o xyz
</pre>

    <p>instead of the more complicated two-stage compilation</p>

<pre>
cc -g -c xyz.c -o xyz.o
cc -g xyz.o -o xyz
</pre>

    <p>if internally the first is converted into the second?  The
    difference is important only if there is more than one module in
    your program.  Suppose we have an additional module,
    <code>abc.c</code>.  Now our compilation looks like this:</p>

<pre>
# One-stage command.
cc -g xyz.c abc.c -o xyz
</pre>

    or

<pre>
# Two-stage command.
cc -g -c xyz.c -o xyz.o
cc -g -c abc.c -o abc.o
cc -g xyz.o abc.o -o xyz
</pre>

    <p>The first method, of course, is converted internally into the
    second method.  This means that both <code>xyz.c</code> and
    <code>abc.c</code> are recompiled each time the command is run.  But
    if you only changed <code>xyz.c</code>, there's no need to recompile
    <code>abc.c</code>, so the second line of the two-stage commands
    does not need to be done.  This can make a huge difference in
    compilation time, especially if you have many modules.  For this
    reason, virtually all makefiles keep the two compilation steps
    separate.</p>

    <p>That's pretty much the basics, but there are a few more little
      details you really should know about.</p>

    <h2>Debugging vs. optimization</h2>

    <p>Usually programmers compile a program either either for debug or
    for speed.  Compilation for speed is called <i>optimization</i>;
    compiling with optimization can make your code run up to 5 times
    faster or more, depending on your code, your processor, and your
    compiler.</p>

    <p>With such dramatic gains possible, why would you ever not want to
    optimize?  The most important answer is that optimization makes use
    of a debugger much more difficult (sometimes impossible).  (If you
    don't know anything about a debugger, it's time to learn.  The half
    hour or hour you'll spend learning the basics will be repayed many
    many times over in the time you'll save later when debugging.  I'd
    recommend starting with a GUI debugger like <code>kdbg</code>,
    <code>ddd</code>, or <code>gdb</code> run from within emacs (see the
    info pages on gdb for instructions on how to do this).)
    Optimization reorders and combines statements, removes unnecessary
    temporary variables, and generally rearranges your code so that it's
    very tough to follow inside a debugger.  The usual procedure is to
    write your code, compile it without optimization, debug it, and then
    turn on optimization.</p>

    <p>In order for the debugger to work, the compiler has to cooperate
    not only by not optimizing, but also by putting information about
    the names of the symbols into the object file so the debugger knows
    what things are called.  This is what the <code>-g</code>
    compilation option does.</p>

    <p>If you're done debugging, and you want to optimize your code,
    simply replace <code>-g</code> with <code>-O</code>.  For many
    compilers, you can specify increasing levels of optimization by
    appending a number after <code>-O</code>.  You may also be able to
    specify other options that increase the speed under some
    circumstances (possibly trading off with increased memory usage).
    See your compiler's man page for details.  For example, here is an
    optimizing compile command that I use frequently with the
    <code>gcc</code> compiler:</p>

<pre>
gcc -O6 -malign-double -c xyz.c -o xyz.o
</pre>

    <p>You may have to experiment with different optimization options
    for the absolute best performance.  You may need different options
    for different pieces of code.  Generally speaking, a simple
    optimization flag like <code>-O6</code> works with many compilers
    and usually produces pretty good results.</p>

    <p>Warning: on rare occasions, your program doesn't actually do
    exactly the same thing when it is compiled with optimization.  This
    may be due to (1) an invalid assumption you made in your code that
    was harmless without optimization, but causes problems because the
    compiler takes the liberty of rearranging things when you optimize;
    or (2) sadly, compilers have bugs too, including bugs in their
    optimizers.  For a stable compiler like <code>gcc</code> on a common
    platform like an pentium, optimization bugs are seldom a problem (as
    of the year 2000--there were problems a few years ago).</p>

    <p>If you don't specify either <code>-g</code> or <code>-O</code> in
    your compilation command, the resulting object file is suitable
    neither for debugging nor for running fast.  For some reason, this
    is the default.  So always specify either <code>-g</code> or
    <code>-O</code>.</p>

    <p>On some systems, you must supply <code>-g</code> on both the
    compilation and linking steps; on others (e.g., linux), it needs to
    be supplied only on the compilation step.  On some systems,
    <code>-O</code> actually does something different in the linking
    phase, while on others, it has no effect.  In any case, it's always
    harmless to supply <code>-g</code> or <code>-O</code> for both
    commands.</p>

    <h2>Warnings</h2>

    <p>Most compilers are capable of catching a number of common
    programming errors (e.g., forgetting to return a value from a
    function that's supposed to return a value).  Usually, you'll want
    to turn on warnings.  How you do this depends on your compiler (see
    the man page), but with the <code>gcc</code> compiler, I usually use
      something like this:</p>

<pre>
gcc -g -Wall -c xyz.c -o xyz.o
</pre>

    <p>(Sometimes I also add <code>-Wno-uninitialized</code> after
    <code>-Wall</code> because of a warning that is usually wrong that
    crops up when optimizing.)</p>

    <p>These warnings have saved me many many hours of debugging.</p>

    <h2>Other useful compilation options</h2>

    <p>Often, necessary include files are stored in some directory other
    than the current directory or the system include directory
    (<code>/usr/include</code>).  This frequently happens when you are
    using a library that comes with include files to define the
    functions or classes.</p>

    <p>Suppose, for example, you are writing an application that uses
    the Qt libraries.  You've installed a local copy of the Qt library
    in <code>/home/users/joe/qt</code>, which means that the include
      files are stored in the directory
      <code>/home/users/joe/qt/include</code>.  In your code, you want
      to be able to do things like this:</p>

<pre>
#include &lt;qwidget.h&gt;
</pre>

    instead of

<pre>
#include "/home/users/joe/qt/include/qwidget.h"
</pre>

    <p>You can tell the compiler to look for include files in a
      different directory by using the <code>-I</code> compilation
      option:</p>

<pre>
g++ -I/home/users/joe/qt/include -g -c mywidget.cpp -o mywidget.o
</pre>

    <p>There is no space between the <code>-I</code> and the directory
    name.</p>

    <p>When the C++ compiler is looking for the file
    <code>qwidget.h</code>, it will look in
    <code>/home/users/joe/qt/include</code> before looking in the system
    include directory.  You can specify as many <code>-I</code> options
    as you want.</p>

    <h2>Using libraries</h2>

    <p>You will often have to tell the linker to link with specific
    external libraries, if you are calling any functions that aren't
    part of the standard C library.  The <code>-l</code> (lowercase L)
      option says to link with a specific library:</p>

<pre>
cc -g xyz.o -o xyz -lm
</pre>

    <p><code>-lm</code> says to link with the system math library, which
      you will need if you are using functions like
      <code>sqrt</code>.</p>

    <p><b>Beware:</b> if you specify more than one <code>-l</code>
    option, the order can make a difference on some systems.  If you are
    getting undefined variables when you know you have included the
    library that defines them, you might try moving that library to the
    end of the command line, or even including it a second time at the
    end of the command line.</p>


    <p>Sometimes the libraries you will need are not stored in the
    default place for system libraries.  <code>-labc</code> searches for
    a file called <code>libabc.a</code> or <code>libabc.so</code> or
    <code>libabc.sa</code> in the system library directories
    (<code>/usr/lib</code> and usually a few other places too, depending
    on what kind of unix you're running).  The <code>-L</code> option
    specifies an additional directory to search for libraries.  To take
    the above example again, suppose you've installed the Qt libraries
    in <code>/home/users/joe/qt</code>, which means that the library
    files are in <code>/home/users/joe/qt/lib</code>.  Your link step
    for your program might look something like this:</p>

<pre>
g++ -g test_mywidget.o mywidget.o -o test_mywidget -L/home/users/joe/qt/lib -lqt
</pre>

    <p>(On some systems, if you link in Qt you will need to add other
    libraries as well (e.g.,
    <code>-L/usr/X11R6/lib&nbsp;-lX11&nbsp;-lXext</code>).  What you need to do
    will depend on your system.)</p>

    <p>Note that there is no space between <code>-L</code> and the
    directory name.  The <code>-L</code> option usually goes before any
    <code>-l</code> options it's supposed to affect.</p>
    
    <p>How do you know which libraries you need?  In general, this is a
    hard question, and varies depending on what kind of unix you are
    running.  The documentation for the functions or classes you are
      using should say what libraries you need to link with.  If you are
      using functions or classes from an external package, there is
      usually a library you need to link with; the library will usually
      be a file called <code>libabc.a</code> or <code>libabc.so</code>
      or <code>libabc.sa</code> if you need to add a <code>-labc</code>
      option.</p>

    <h2>Some other confusing things</h2>

    <p>You may have noticed that it is possible to specify options which
      normally apply to compilation on the linking step, and options
      which normally apply to linking on the compilation step.  For
      example, the following commands are valid:</p>

<pre>
cc -g -I/somewhere/include xyz.o -o xyz
cc -g -L/usr/X11R6/lib -c xyz.c -o xyz
</pre>

    <p>The irrelevant options are ignored; the above commands are
      exactly equivalent to this:</p>

<pre>
cc -g xyz.o -o xyz
cc -g -c xyz.c -o xyz
</pre>

    <hr>
    <a href="t_index.html">Tutorial index</a>
    |
    <a href="t_simplest.html">Next (a simple makefile)</a>
    |
    <a href="t_builtin.html">Previous (do I need a makefile?)</a>
    <br>
<!-- Created: Wed Dec 27 11:25:21 PST 2000 -->
<!-- hhmts start -->
Last modified: Wed Dec 27 13:25:58 PST 2000
<!-- hhmts end -->
  </body>
</html>

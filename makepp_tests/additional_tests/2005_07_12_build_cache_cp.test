###	SPAR <http://www.cpan.org/scripts/>
###	1	644	1145710484	1121190843	Makeppfile
$(phony default): foo
###	D	755	1121192534	1121189776	answers
###	1	644	1121189769	1121189769	answers/n1
2 0
###	1	644	1121189776	1121189776	answers/n2
0 0
###	1	644	1121189769	1121189769	answers/n_files
0 0
###	3	644	1121191772	1121188739	foo.c
int main() {
    return 0;
}
###	24	755	1164320845	1121192513	makepp_test_script.pl
makepp \'builtin', qw(-MBuildCacheControl create build_cache);

# Populate the cache
makepp '--build-cache=build_cache', '--force-copy-from-bc', '--stop-on-race';
n_files 'n1';

# Now get a new foo.o with an update timestamp.  If it works properly, then
# the foo executable will still come from the cache, because it uses an MD5 of
# foo.o in its cache key instead of the timestamp.
wait_timestamp 'foo.o';
unlink 'foo.o' or die "Can't unlink foo.o";
makepp '--build-cache=build_cache', '--force-copy-from-bc', '--stop-on-race';
n_files 'n2';

# Make sure that the DEP_SIGS in the 'foo' executable build info was updated,
# so that it ooks up-to-date even though the foo.o timestamp is different from
# the DEP_SIGS in the build cache.
makepp;

die unless -d 'build_cache/incoming.dir';
my @garbage = glob 'build_cache/incoming.dir/*';
die "@garbage" if @garbage;

1;
